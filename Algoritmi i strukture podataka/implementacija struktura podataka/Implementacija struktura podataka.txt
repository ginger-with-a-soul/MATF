Kontejnteri si: array, vector, list, forward-list i deque
Adapteri kontejnera su: stack, queue, priority queue
Asocijativno kontejneri su: set, multiset, map i  multimap
Neuredjeni asocijativni kontejneri su: unordered_set, unordered_mutliset,
									   unordered_map, unordered_multimap

List je implementiran preko dvostruko povezane liste a forward_list preko jednostuko
Deque je vector pokazivaca na nizove fiksne velicine

Svaki adapter kontejnera pruza jedinsven interfejs sa kojim se podaci manipulisu i skladiste
u kontejnere. Svaki adapter ima default kontejner ali on moze biti promenjen. Stack na primer
koristi vector ali moze da se definise i da koristi list. Queue implementira funkcije reda
i koristi deque dok priority_queue koristi vector kao kontejner.

Asocijativno kontejneri implementirani su preko samobalansirajucih uredjenih binarnih drveta.
Set je samobalansirajuce uredjeno binarno drvo u cijim cvorovima se nalaze vrednosti koje 
se ne mogu ponavljati. Multiset je takodje samobalansirajuce uredjeno binarno drvo ali u njegovim cvorovima mogu se nalaziti iste vrednosti ili se mogu nalaziti vrednosti samo jednom uz broj ponavljanja tog elementa. Map i multimap ekivalentni su setu i multisetu samo sto se kod njih u cvorovima nalaze podaci o kluci u vrednosti koja je pridruzena svakom kljucu.

Vector prestavlja dinamicki alocirani niz koji se u C++u sam povecava po potrebi. Kod vectora indeksni pristup je u konstantnom vremenu dok je dodavanje na kraj u amortizovanom konstantnom vremenu ako se povecanje velicine vrse preko geometrijske progresije.

Forward-list je jednostruko povezana lista kod koje u svakom cvoru pored vrenosti pamti i pokazivac na sledeci cvor. Kod ovakve liste, ukoliko znamo pokazivac na pocetak i kraj,
dodavanje na pocetak i kraj, kao i brisanje sa kraja je u O(1) dok je brisanje sa pocetka u   O(n). Ukoliko zelimo da dodamo cvor posle nekog ciji pokazivac znamo, onda to mozemo uraditi u O(1) ali ukoliko nemamo taj pokazivac onda je dodavanje u listu O(n). Pristup odr. cvoru je takodje O(n).

List je dvostruko povezana lista kod koje se pored vrednosti cuvaju i pokazivaci na prethodni i sledeci element. Dodavanje na pocetak i kraj ukoliko znamo oba ova pokazivaca, kao i brisanje sa pocetka i kraja je u O(n). Sve ostale vremenske slozenosti su iste.

Mane listi u odnosu na vector i deque su sto zauzimaju vise memorije jer je neophodno pamtiti i pokazivace. Pored ovoga, liste se danas retko koriste i zbog velike upotrebe kes memorije koja se zasniva na sekvencijalnom skladistenju podataka koje kod vectora postoji a kod listi ne. Prednost listi je sto kod velike kolicine podataka nema realokacije ukoliko se premasi trenutno rezervisani prostor koji kod vectora postoji.

Deque prestavlja nacin implementacije reda sva dva kraja. Kao i kod listi, dodavanje na pocetak i kraj moguce je u O(1) - amortizovanom. Prednost u odnosu na liste je sto je moguc pristum proizvoljnom elementu u O(1) te je moguca i binarna pretraga ali je brisanje elementa u sredini u O(n). Deque je implementiran kao vector pokazivaca na segmente (bilo staticki ili dinamicki alocirane) iste duzine. Kljucni su levi i desni segment koji nikada ne mogu biti skroz popunjeni i kod kojih se uvek pamti prva prazna pozicija. Ukoliko se neki od ova dva segmenta popuni, prethodni (kod levog) odnosno sledeci (kod desnog) segment postaje levi odnosno desni. Ukoliko nema praznih prethodnih tj. sledecih segmenata od levog tj. desnog, dolazi do prosirivanja dequa-a tako sto je prosiri vector pokazivaca na nove segmente. Obicno se prosirivanje vrsi u geometrijskoj progresiji zarad dobijanja amortizovanog dodavanja i brisanja sa kraja tj. pocetka.

Binarna drveta mogu biti uredjena (drveta pretrage) koja se koriste za implementaciju seta, mape, multiseta, multimape ili mogu biti hip drveta koja se koriste za implementaciju redova sa prioritetom. Drveta su rekurzivno defenisane strukture podataka pa je nad njima najlase implementirati rekurzive funkcije koje ako su repne mogu lako biti transformisane ali ako nisu nekada je potrebno koristiti stek za trans. iz rekurzivne u iterativnu.

Drvo je uredjeno ako je prazno ili ako su i desno i levo poddrvo uredjeni i vrednost u korenu je veca od maksimalne vrednosti u levom poddrvetu i manja od minimalne vrednosti u desnom poddrvetu. Balansirana binarna drveta garantuju da ce operacije pristupa, ubacivanja i brisanja elementa iz drveta biti u O(logn) (n je broj cvorova) vremenskoj slozenosti. Ukoliko drvo nije balansirano, operacije pristupa, ubacivanja i brisanja cvorova teze linearnoj vremenskoj slozenosti. Dve najcesce strukture podataka koje se zasnivaju na balansiranim binarnim drvetima su: AVL drveta i Crveno-Crna drveta.

AVL drveta garantuju vremensku slozenost za pronalazenje, umetanje i brisanje cvora O(logn) zato sto se nakon svake operacije ulaze napor da se drvo izbalansira tako da je visina drveta uvek O(logn), tj. da za svaki cvor vazi da je razlika u visini levog i desnog deteta ili 0 ili 1. Prilikom umetanja novog cvora prvo se pronalazi mesto gde treba da se smesti, zatim se razmatraju svi cvorovi na putu do tog mesta i njihovi faktori ravnoteze koji mogu biti -1, 0, 1. Ukoliko je kriticni cvor na visini +1, moze doci do degeneracije drveta ali ispostavlja se da se balansiranjem cvorova koji su na putu do kriticnog postize balansiranje celog drveta. Vreme izvrsavanja brisanja cvore je ograniceno sa O(logn)

RB drveta su uredjena balanstirana binarna drveta koja moraju da zadovoljavaju sledece:
	1. svaki cvor je ili crn ili crven
	2. koren je crn
	3. cvor je crven ako ima dva crna deteta
	4. svi listovi su crni i ne sadrze vrednost
	5. sve putanje od nekog cvora do njegovih listova sadrze isti broj crnih cvorova
Ovih 5 pravila nam garantuju da ce putanja od korena do njemu najdaljeg lista biti najvise dva puta duza od putanje korena do njemu najblizeg lista. Ovo nam garantuje neki vid balansiranosti i logaritamsku slozenost operacija.

Hip je binarno drvo ciji svaki nivo, sem eventualno poslednjeg, potpuno popunjen. Max-hip je hip kod koga je vrednost u svakom cvoru veca ili jednaka vrednosti njegove dece, dok je min-hip hip kod kojeg je vrednost u cvoru manja ili jednaka vrednosti njegove dece. Max i Min su pogodni za odredjivanje maksimalnog ili minimalnog elementa i oni se uvek nalaze u korenu. Posto je i operacija umetanja elemenata u hip efikasna, on se moze koristiti za implementiranje reda sa prioritetom. Iz Max-hipa najveci element mozemo ukloniti izbacivanjem korena i na njegovo mesto stavljanjem najdesnjeg deteta koje se nalazi na poslednjem nivou. Time zadovoljavamo uslov da je svaki nivo sem eventualno poslednjeg i dalje popunjen ali vrednost u korenu sada ne mora, i najcesce nije, maksimalna. To se lako da ispraviti jednim poredjenjem sa desnim detetom trenutnog korena. Dalje se prethodni koren pomera na dole dokle god ima dete koje je vece od njega. Najvise ce biti h pomeraja gde je h visina drveta. U potpunom drvetu visine h moze da stane 2^h+1 - 1 elemenata pa visina logaritamski zavisi od broja elemenata, te je u najgorem slucaju za uklanjanje max elementa potrebno O(logn) vremena. Ubacivanje elementa u Max-hip je slicno izbacivanju. Razlika je sto se element ubacuje na poslednji nivo i pita se da li je veci od roditelja, ako jeste oni se menjaju, i tako dok novi element ne dodje na svoje mesto.

Heap sort je varijacija selection sorta kod koje se svi elementi niza koji zelimo da sortiramo stavljaju i hip a zatim se iz njega vade i postavljaju na kraj vektora. Moze se koristiti isti vektor u kome se nalazi elementi za sortiranje i za pravljenje hipa i za kasnije izbacinje iz hipa i sortiranje. Na jednom kraju vektora se pravi hip a na drugom se smestaju izbaceni elementi iz hipa i taj deo je sortiran. Da bismo ovo postigli, neophodno je funkcijama koje rade sa nasim hipom proslediti i trenutnu velicinu hipa kako nista posle njega, odnosno obradjeni deo ne bi bio pregazen.

Formiranje hipa nanize (Vilijamsov metod) od proizvoljnog niza formira hip tako sto umece element po element. Invarijanta je da svi elementi [0, i) cine hip pa ce svako dodatno ubacivanje do kraja takodje biti hip. Umetanje elementa u hip koji ima k elemenata je O(logk) pa je suma vremenske slozenosti umetanja elemenata od 1 do n O(nlogn)

Drugi metod formiranja hipa je navise (Flojdov metod). On podrazumeva da krene od pozadi niza i da se svaki element umetne u hip tako sto se spusta nanize kroz njega. Formiranje hipa navise ima bolju asimptotsku slozenost O(n) umesto O(nlogn).

Hesiranje je nacin skladistenja podataka koje se zasniva na hesh funckijama i kod kojeg je prostor za skladistenje tek malo veci od prostora potrebnog za same podatke. Prednost hesiranja od drugih nacina skladistenja i pristupa podacima je sto je vreme pristupa bilo kojim podacima u proseku konstantno ali postoje i granicni slucajevi u kojima to znatno duze. Najgori slucaj je O(n) vremenska slozenost i do nje dolazi ako se hesh tabela prepuni i onda je potrebno rehashirati, ili ako se previse elemenata heshira u isti kljuc (kolizija). Dobrom hash funkcijom ovo drugo se moze skoro potpuno eliminisati. Kolizija se moze resiti i povecanjem hesh tabele jer se tada pripadnost odr elemenata odredjuje preko novog modula. Moze se resiti i tako sto se pojedinacno polje sastoji od povezane liste elemenata. U C++u postoji posebna Hash struktura koja je pogodna za cuvanje svih tipova i lako racunanje hash vrednosti. Hash se koristi i za implementaciju struktura kojima redosled podataka u strukturi nije vazan (unordere_set, unordered_map). Hesh funkcija kompresuje proizvoljno veliki broj na manji, radi u jednom smeru i iz dobijene hesh vrednosti se ne moze povratiti prvobitna vrednost

Prefiksno drvo je uredjeno binarno drvo koje je pogodno za implementiranje struktura sa asocijativnim pristupom podacima. Kljuc na osnovu koje se dobija podatak gradi se prolaskom od korena do lista/cvora. Najcesce se koristi za implementaciju konacnih recnika kod kojih se reci grade od slova koja se nalaze u cvorovima. Pored vrednosti (slova), u cvoru mora da se nadje i informacija o tome da li je on kraj neke reci. U korenu se nalazi prazna rec. Najgora slozenost za pronalazak reci kod konacne azbuke (n slova) gde je duzina reci m je O(nm).

Union-find prestavlja podelu skupa na disjunktne podstkupove u kojoj je potrebno lako pronaci kom podskupu neki element pripada (find). Pored ovoga potrebno je i moci spojiti sve podskupove u veci skup (union). Najjednostavniji pristup bio bi da za svaki element (svi su jedinstveni i razliciti) u vektoru na indeksu koji je jednak vrednosti cuvamo kom podkupu pripada. Tada bi find bio O(1) ali bi union bio O(n) jer je za podskup od n elemenata potrebno promeniti informaciju o tome kom podksupu pripada. Efikasnije je koristiti drvo za svaki podskup i elemente slikati u roditelje a koren, u kom stoji sama oznaka podskupa, slikati u samog sebe. Na ovaj nacin, da bismo saznali kom podskupu element pripada neophodno je da prodjemo kroz niz roditelja i tada cemo saznati kom podskupu element pripada. Kod ovog drveta pokazivaci idu od dece ka roditeljima. Kao da kada promenimo adresu, umesto da zovemo svakog i govorimo mu novu adresu, mi ostavimo nasu novu adresu na starom mesto. Ako cesto menjamo mesto onda ce niz preusmeravanja biti veci ali je ovakav pristup generalno efikasniji. Uniju mozemo vrsiti usmeravanjem jednog korena ka drugom. Ukoliko je stablo degenerisano onda je ono lista i tada je za pronalazak kom podskupu element pripada potrebno  O(n) umesto O(1) kod prvog pristupa. Zato je vazno da stablo bude balansirano i operacije ce biti u logaritamskoj vremenskoj slozenosti. Drvo moze da se degenerise samo prilikom nekih izmena a one se desavaju samo kod uniranja. Ovo moze da se spreci ako pazimo da visina uniranog drveta bude ista kao visine ostalih drveta. To se moze uraditi ako koren kraceg drveta usmerimo ka korenu duzeg drveta. Tada ce se rang povecati samo ako su duzine dva drveta iste. Ovime se dobija O(logn) slozenost i za find i za union.  


